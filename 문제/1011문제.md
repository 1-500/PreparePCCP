# (1011) 기록

## 문제리스트

- () [추억 점수](https://school.programmers.co.kr/learn/courses/30/lessons/176963)
- (단순구현) [신고 결과 받기](https://school.programmers.co.kr/learn/courses/30/lessons/92334)
- (자료구조) [옹알이(1)](https://school.programmers.co.kr/learn/courses/30/lessons/120956)

## (추억 점수)

### 1번문제 접근방법

- 각 사진 별로 추억 점수가 있는 사람들의 점수를 js Array 메소드를 이용해 더함

### 풀이 코드

```javascript
function solution(name, yearning, photo) {
    return photo.map((e, i) => (
        e.reduce((acc, cur) => {
            const nameIndex = name.findIndex(n => n === cur);
            return acc + (nameIndex >= 0 ? yearning[nameIndex] : 0);
        }, 0)
    ));
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 자바스크립트 배열의 여러 메소드를 이용하니 코드를 간단하게 작성해 풀 수 있었다.

## (신고 결과 받기)

### 2번문제 접근방법

1. 각 신고 데이터에 대해 순회를 돌며 각 유저가 신고한 유저에 대한 데이터와 신고 당한 횟수에 기록
2. 각 아이디 별로 신고한 유저 중 신고 당한 횟수가 k번 이상인 유저의 수를 배열에 기록해 반환

### 풀이 코드

```javascript
function solution(id_list, report, k) {
    const reportId = {};
    const reportedCount = {};

    id_list.forEach(id => {
        reportId[id] = [];
        reportedCount[id] = 0;
    });

    report.forEach(r => {
        const reportData = r.split(' ');
        if (!reportId[reportData[0]].includes(reportData[1])) {
            reportId[reportData[0]].push(reportData[1]);
            reportedCount[reportData[1]]++;
        }
    })

    return id_list.map(id => {
        let mailCount = 0;
        Object.entries(reportedCount)
            .filter(reported => reported[1] >= k)
            .forEach(reported => {
                if (reportId[id].includes(reported[0])) {
                    mailCount++;
                }
            });
        return mailCount;
    })
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 신고를 중복으로 할 수 없다는 조건을 처음에 추가하지 않아 오류가 났었다. 조건을 잘 읽어야..
- 코드의 실행 시간이 조금 긴 것 같아 더 줄일 방법이 있는지 생각해봐야 할 것 같다.

## (옹알이(1))

### 3번문제 접근방법

1. 인덱스 0부터 시작해 babbling의 해당 인덱스 글자가 발음의 첫 글자와 일치하는 경우가 있는지 확인
2. 있으면 일치하는 발음의 글자 수만큼 substring으로 분리해 일치하는지 확인
3. 일치하면 글자 수 만큼 인덱스에 더하고, 일치하지 않으면 발음할 수 없는 것으로 간주
4. 끝까지 일치한다면 발음할 수 있는 것으로 간주

### 풀이 코드

```javascript
function solution(babbling) {
    return babbling.filter((b) => {
        const domain = ['aya', 'ye', 'woo', 'ma'];

        let i = 0;
        while (i < b.length) {
            const domainIndex = domain.findIndex((d) => d.charAt(0) === b.charAt(i));
            if (domainIndex >= 0) {
                if (b.substring(i, i + domain[domainIndex].length) === domain[domainIndex]) {
                    i += domain[domainIndex].length;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
        return true;
    }).length;
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 뭔가 더 깔끔하게 작성할 수 있는 알고리즘이 있을 것 같은데..... 고민해봐야 할 듯
