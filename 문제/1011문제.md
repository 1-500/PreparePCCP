# (1011) 기록

## 문제리스트

- () [추억 점수](https://school.programmers.co.kr/learn/courses/30/lessons/176963)
- (단순구현) [신고 결과 받기](https://school.programmers.co.kr/learn/courses/30/lessons/92334)
- (자료구조) [옹알이(1)](https://school.programmers.co.kr/learn/courses/30/lessons/120956)

## (추억 점수)

### 1번문제 접근방법

- 각 사진 별로 추억 점수가 있는 사람들의 점수를 js Array 메소드를 이용해 더함

### 풀이 코드

```javascript
function solution(name, yearning, photo) {
    return photo.map((e, i) => (
        e.reduce((acc, cur) => {
            const nameIndex = name.findIndex(n => n === cur);
            return acc + (nameIndex >= 0 ? yearning[nameIndex] : 0);
        }, 0)
    ));
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 자바스크립트 배열의 여러 메소드를 이용하니 코드를 간단하게 작성해 풀 수 있었다.

## (신고 결과 받기)

### 2번문제 접근방법

1. 각 신고 데이터에 대해 순회를 돌며 각 유저가 신고한 유저에 대한 데이터와 신고 당한 횟수 객체에 기록
2. 각 아이디 별로 신고한 유저 중 신고 당한 횟수가 k번 이상인 유저의 수를 배열에 기록해 반환

### 풀이 코드

```javascript
function solution(id_list, report, k) {
    const reportId = {};
    const reportedCount = {};

    id_list.forEach(id => {
        reportId[id] = [];
        reportedCount[id] = 0;
    });

    report.forEach(r => {
        const reportData = r.split(' ');
        if (!reportId[reportData[0]].includes(reportData[1])) {
            reportId[reportData[0]].push(reportData[1]);
            reportedCount[reportData[1]]++;
        }
    });

    return id_list.map(id => {
        let mailCount = 0;
        Object.entries(reportedCount)
            .filter(reported => reported[1] >= k)
            .forEach(reported => {
                if (reportId[id].includes(reported[0])) {
                    mailCount++;
                }
            });
        return mailCount;
    });
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 신고를 중복으로 할 수 없다는 조건을 처음에 추가하지 않아 오류가 났었다. 조건을 잘 읽어야..
- 코드의 실행 시간이 조금 긴 것 같아 더 줄일 방법이 있는지 생각해봐야 할 것 같다.

## (옹알이(1))

### 3번문제 접근방법

- 첫번째 풀이(정답이긴 하지만 문제 조건과는 다름)
1. 인덱스 0부터 시작해 babbling의 해당 인덱스 글자가 발음의 첫 글자와 일치하는 경우가 있는지 확인
2. 있으면 일치하는 발음의 글자 수만큼 substring으로 분리해 일치하는지 확인
3. 일치하면 글자 수 만큼 인덱스에 더하고, 일치하지 않으면 발음할 수 없는 것으로 간주
4. 끝까지 일치한다면 발음할 수 있는 것으로 간주

- 두번째 풀이
1. 옹알이의 첫 글자부터 각 발음에 대해 발음의 길이만큼 자른 문자가 해당 발음과 일치하는 경우의 인덱스 확인
2. 인덱스가 0보다 작으면 발음할 수 없는 것으로 간주
3. 인덱스가 0보다 크면 그만큼 옹알이에서 자르고 발음 리스트에서도 삭제
4. 옹알이의 길이가 0이 되면 발음할 수 있는 것으로 간주

### 풀이 코드

- 첫번째 풀이
```javascript
function solution(babbling) {
    return babbling.filter((b) => {
        const domain = ['aya', 'ye', 'woo', 'ma'];

        let i = 0;
        while (i < b.length) {
            const domainIndex = domain.findIndex((d) => d.charAt(0) === b.charAt(i));
            if (domainIndex >= 0) {
                if (b.substring(i, i + domain[domainIndex].length) === domain[domainIndex]) {
                    i += domain[domainIndex].length;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
        return true;
    }).length;
}
```
- 두번째 풀이
```javascript
function solution(babbling) {
    return babbling.filter((b) => {
        const domain = ['aya', 'ye', 'woo', 'ma'];
        
        while (b.length > 0) {
            const i = domain.findIndex(d => d === b.substring(0, d.length));
            if (i >= 0) {
                b = b.slice(domain[i].length);
                domain.splice(i, 1);
            } else {
                return false;
            }
        }
        return true;
    }).length;
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 처음으로 작성한 코드를 제출했을 때 정답처리는 됐었지만, 다시 보니 문제의 조건과 맞지 않는 부분이 있다는 것을 알았다.
- 문제에서는 각 발음이 한번씩 밖에 들어가지 않지만 코드에서 그 조건을 포함하지 않았다.
- 이 조건을 생각하며 좀 더 간결하고 깔끔한 코드를 작성할 수 있었다.
