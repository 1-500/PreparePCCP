# (1017) 기록

## 문제리스트

- (정렬) [파일명 정렬](https://school.programmers.co.kr/learn/courses/30/lessons/17686)
- (스택/큐) [프로세스](https://school.programmers.co.kr/learn/courses/30/lessons/42587)


### 풀이 코드

```javascript
function solution(files) {
    return files.sort((a, b) => {
        const [aHead, aNumber] = splitFileName(a);
        const [bHead, bNumber] = splitFileName(b);
        
        const headCompare = aHead.localeCompare(bHead);
        if (headCompare !== 0) return headCompare;
        
        return parseInt(aNumber) - parseInt(bNumber);
    });
}

function splitFileName(fileName) {
    const match = fileName.match(/^([a-zA-Z-\s.]+)(\d{1,5})/i);
    return [match[1].toLowerCase(), match[2]];
}
```

### 토론

`

- 어떻게 풀이에 접근했나요?
  - 파일명을 HEAD와 NUMBER 부분으로 나누는 함수를 먼저 작성하자.
  - 정규표현식을 사용(검색^0^)하여 HEAD와 NUMBER를 추출하고 sort사용해 정렬

- 어떤 방식을 사용해야겠다고 생각했나요?
  - 문자열 비교를 위해 localeCompare 메서드를 사용했습니다.
  - NUMBER 부분은 정수로 변환하여 비교했습니다.

- 뭐가 어려웠나요?
  - 정규표현식은 여전히 어렵다. 검색없이 할 수 있게 몇개는 외우는게 좋다고 생각합니다.
  - 대소문자 구분 없이 정렬이 이해가 안되었습니다.

- 추가 설명:
  - splitFileName 함수는 파일명을 HEAD와 NUMBER로 나눕니다.
`

## 2번문제 [프로세스]


### 풀이 코드

```javascript
function solution(priorities, location) {
    let queue = priorities.map((priority, index) => ({priority, index}));
    let count = 0;
    
    while (queue.length > 0) {
        let current = queue.shift();
        if (queue.some(item => item.priority > current.priority)) {
            queue.push(current);
        } else {
            count++;
            if (current.index === location) {
                return count;
            }
        }
    }
}
```

### 토론

`

- 어떻게 풀이에 접근했나요?
  - 우선순위, 인덱스를 객체 배열을 만들어 큐로 사용했습니다.
  - 큐의 첫 번째 요소를 꺼낸다음 남은 것들 중 높은 우선순위가 있는지 확인하고 있다면 큐의 끝에 넣고 없다면 횟수 증가로 접근

- 어떤 방식을 사용해야겠다고 생각했나요?
  - 처음 메서드가 헷갈렸지만 shift, push 메서드를 사용해 풀이 시작
  - some 메서드를 활용해 높은 우선순위의 확인하는 과정을 생각

- 뭐가 어려웠나요?
  - 원래 위치를 추적, 우선순위에 따라 재정렬하는 것을 구현하는게 이해하기 까다로웠다..

- 추가 설명:
  - 찾아보니 이 풀이의 시간 복잡도는 O(n^2)이라고 했습니다. 하지만 이 문제에서 주어진 제한 사항(최대 100개의 프로세스)에서는 괜찮다고 생각됩니다!
`