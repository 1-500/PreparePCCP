# (1011) 기록

## 문제리스트

- (완전탐색) [최소직사각형](https://school.programmers.co.kr/learn/courses/30/lessons/86491)
- (완전탐색) [모음사전](https://school.programmers.co.kr/learn/courses/30/lessons/84512)
- (정렬) [H-Index](https://school.programmers.co.kr/learn/courses/30/lessons/42747)

## (최소직사각형)

### 1번문제 접근방법

- 각 명함에 대해서 가로, 세로값을 정해서 최댓값을 찾는 걸로 계획을 세움

### 풀이 코드

```javascript
function solution(sizes) {
  let maxWidth = 0;
  let maxHeight = 0;

  // 각 명함을 돌면서, 큰 값은 가로, 작은 값은 세로로 정렬
  // widht, height를 배열구조로 받음
  for (const [w, h] of sizes) {
    const [longer, shorter] = w > h ? [w, h] : [h, w];
    maxWidth = Math.max(maxWidth, longer);
    maxHeight = Math.max(maxHeight, shorter);
  }

  // 최댓값들을 곱한 결과 반환
  return maxWidth * maxHeight;
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

-

## (모음사전)

### 2번문제 접근방법

- 알파벳 순서를 저장하고, 자리수마다 점수를 구현.
- 각 자리에 조합을 계산하고 문자를 반복하며 index넘버를 찾는다.
- 인덱스 값에 곱을 값에 더한다.

### 풀이 코드

```javascript
function solution(word) {
  const vowels = ["A", "E", "I", "O", "U"];
  const weights = [781, 156, 31, 6, 1];

  let result = 0;

  for (let i = 0; i < word.length; i++) {
    const index = vowels.indexOf(word[i]);
    result += index * weights[i] + 1;
  }
  return result;
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 각 자리에 조합이 얼만큼을 지정해야할지 생각하는 것이 까다롭

## (H-Index)

### 3번문제 접근방법

- 논문이 이용된 횟수를 정렬하고 논문 수와 이용된 것을 사용
- 반복을 돌리면서 인용 횟수의 값이 반복 index보다 크다면 hIndex를 늘리고 아니면 return

### 풀이 코드

```javascript
function solution(citations) {
  citations.sort((a, b) => b - a);

  let hIndex = 0;
  for (let i = 0; i < citations.length; i++) {
    if (citations[i] >= i + 1) {
      hIndex = i + 1;
    } else {
      break;
    }
  }

  return hIndex;
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 문제 해석에 시간이 조금 걸렸습니다.
