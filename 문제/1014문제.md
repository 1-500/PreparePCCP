# (1011) 기록

## 문제리스트

- (완전탐색) [최소직사각형](https://school.programmers.co.kr/learn/courses/30/lessons/86491)
- (완전탐색) [모음사전](https://school.programmers.co.kr/learn/courses/30/lessons/84512)
- (정렬) [H-Index](https://school.programmers.co.kr/learn/courses/30/lessons/42747)

## (최소직사각형)

### 1번문제 접근방법

1. sizes 내의 각 배열 요소를 크기 순으로 정렬 (긴 것을 가로, 짧은 것을 세로로 간주하고 가로는 가로끼리, 세로는 세로끼리 맞춘다는 생각)
2. 가로 중 가장 긴 길이를 지갑의 가로로, 세로 중 가장 긴 길이를 지갑의 세로로 정하면 모든 명함을 넣을 수 있음

### 풀이 코드

```javascript
function solution(sizes) {
    sizes.forEach(size => {
        size.sort((a, b) => a - b);
    });
    return Math.max(...sizes.map(size => size[0])) * Math.max(...sizes.map(size => size[1]));
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

## (모음사전)

### 2번문제 접근방법

- 모음사전을 미리 만들어놓고 단어가 존재하는 index 확인
- 재귀함수를 이용해 입력받은 문자에 각 모음을 더한 후 다시 함수를 호출해 사전에 추가하도록 구현

### 풀이 코드

```javascript
function solution(word) {
    const vowels = ['A', 'E', 'I', 'O', 'U'];
    const dictionary = [];
    const makeDictionary = (word, length) => {
        if (length > 5) {
            return;
        }
        dictionary.push(word);
        vowels.forEach(vowel => {
            makeDictionary(word + vowel, length + 1);
        });
    }

    makeDictionary('', 0);
    return dictionary.indexOf(word);
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 사전을 만드는 알고리즘을 생각하는 것이 까다로웠다.

## (H-Index)

### 3번문제 접근방법

1. citations 배열을 내림차순으로 정렬
2. 배열의 마지막부터 처음까지 순회돌며 i번째 값이 i + 1(인덱스는 0부터 시작하기 때문에) 이상이면 i + 1이 H-Index

### 풀이 코드

```javascript
function solution(citations) {
    citations.sort((a, b) => b - a);
    if (citations[0] === 0) {
        return 0;
    }
    for (let i = citations.length - 1; i >= 0; i--) {
        if (citations[i] >= i + 1) {
            return i + 1;
        }
    }
}
```

### (어려웠던점, 오류, 느낀점 한 줄 작성란)

- 배열이 모두 0으로 이루어진 경우는 0을 리턴해야 한다는 예외를 생각해야 한다.
